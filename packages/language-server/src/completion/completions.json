{
  "primitiveTypes": [
    {
      "label": "String",
      "documentation": "Variable length text"
    },
    {
      "label": "Boolean",
      "documentation": "True or false value"
    },
    {
      "label": "Int",
      "documentation": "Integer value"
    },
    {
      "label": "Float",
      "documentation": "Floating point number"
    },
    {
      "label": "DateTime",
      "documentation": "Timestamp"
    },
    {
      "label": "Json",
      "documentation": "A JSON object"
    }
  ],
  "blockTypes": [
    {
      "label": "datasource",
      "documentation": "The datasource block tells the schema where the models are backed."
    },
    {
      "label": "generator",
      "documentation": "Generator blocks configure which clients are generated and how they're generated. Language preferences and binary configuration will go in here."
    },
    {
      "label": "model",
      "documentation": "Models represent the entities of your application domain. They are defined using model blocks in the data model."
    },
    {
      "label": "enum",
      "documentation": "Enums are defined via the enum block. You can define enums in your data model if they're supported by the data source you use:\n• PostgreSQL: Supported\n• MySQL: Supported\n• MariaDB: Supported\n• SQLite: Not supported"
    }
  ],
  "dataSourceFields": [
    {
      "label": "provider",
      "documentation": "Describes which data source connector to use. Can be one of the following built in datasource providers: `postgresql`, `mysql` or `sqlite`."
    },
    {
      "label": "url",
      "documentation": "Connection URL including authentication info. Each datasource provider documents the URL syntax. Most providers use the syntax provided by the database, [learn more](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema)."
    }
  ],
  "generatorFields": [
    {
      "label": "provider",
      "documentation": "Describes which generator to use. This can point to a file that implements a generator or specify a built-in generator directly."
    },
    {
      "label": "output",
      "documentation": "Determines the location for the generated client, [learn more](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema)"
    },
    {
      "label": "binaryTargets",
      "documentation": "Specifies the OS on which the Prisma Client will run to ensure binary compatibility of the query engine."
    },
    {
      "label": "previewFeatures",
      "documentation": "Enables preview feature flags."
    }
  ],
  "blockAttributes": [
    {
      "label": "@@map([])",
      "documentation": "Maps a model name from the Prisma schema to a different table name.",
      "fullSignature": "@@map(_ name: String)",
      "params": [
        {
          "label": "name",
          "documentation": "The name of the target database table."
        }
      ]
    },
    {
      "label": "@@id([])",
      "documentation": "Defines a multi-field ID on the model.",
      "fullSignature": "@id(_ fields: FieldReference[])",
      "params": [
        {
          "label": "fields",
          "documentation": "A list of references."
        }
      ]
    },
    {
      "label": "@@unique([])",
      "documentation": "Defines a compound unique constraint for the specified fields.",
      "fullSignature": "@@unique(_ fields: FieldReference[])",
      "params": [
        {
          "label": "fields",
          "documentation": "A list of references."
        }
      ]
    },
    {
      "label": "@@index([])",
      "documentation": "Defines an index on the model.",
      "fullSignature": "@@index(_ fields: FieldReference[])",
      "params": [
        {
          "label": "fields",
          "documentation": "A list of references."
        }
      ]
    }
  ],
  "fieldAttributes": [
    {
      "label": "@id",
      "fullSignature": "@id",
      "documentation": "Defines a single-field ID on the model.",
      "params": []
    },
    {
      "label": "@unique",
      "fullSignature": "@unique",
      "documentation": "Defines a unique constraint for this field.",
      "params": []
    },
    {
      "label": "@map()",
      "documentation": "Maps a field name from the Prisma schema to a different column name.",
      "fullSignature": "@map(_ name: String)",
      "params": [
        {
          "label": "name",
          "documentation": "The name of the target database column."
        }
      ]
    },
    {
      "label": "@default()",
      "documentation": "Defines a default value for this field. `@default` takes an expression as an argument.",
      "fullSignature": "@default(_ expression: Expression)",
      "params": [
        {
          "label": "expression",
          "documentation": "An expression (e.g. `5`, `true`, `now()`)."
        }
      ]
    },
    {
      "label": "@relation()",
      "documentation": "Defines meta information about the relation. [Learn more](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/relations#the-relation-attribute).",
      "fullSignature": "@relation(_ name: String?, fields: FieldReference[]?, references: FieldReference[]?)",
      "params": [
        {
          "label": "name",
          "documentation": "Defines the name of the relationship. In an m-n-relation, it also determines the name of the underlying relation table."
        },
        {
          "label": "fields",
          "documentation": "A list of field references of the *current* model."
        },
        {
          "label": "references",
          "documentation": "A list of field references of the model on *the other side of the relation*."
        }
      ]
    },
    {
      "label": "@updatedAt",
      "fullSignature": "@updatedAt",
      "documentation": "Automatically stores the time when a record was last updated.",
      "params": []
    }
  ],
  "relationArguments": [
    {
      "label": "references: []",
      "fullSignature": "references: []",
      "documentation": "A list of field references of the model on *the other side of the relation*.",
      "params": []
    },
    {
      "label": "fields: []",
      "fullSignature": "fields: []",
      "documentation": "A list of field references of the *current* model.",
      "params": []
    },
    {
      "label": "\"\"",
      "fullSignature": "\"\"",
      "documentation": "Defines the name of the relationship. In an m-n-relation, it also determines the name of the underlying relation table.",
      "params": []
    }
  ],
  "datasourceUrlArguments": [
    {
      "label": "\"\"",
      "fullSignature": "\"\"",
      "documentation": "Connection URL including authentication info. Each datasource provider documents the URL syntax. Most providers use the syntax provided by the database, [learn more](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema).",
      "params": []
    },
    {
      "label": "env()",
      "fullSignature": "env(_ environmentVariable: string)",
      "documentation": "Specifies a data source via an environment variable. When running a Prisma CLI command that needs the database connection URL (e.g. `prisma generate`), you need to make sure that the `DATABASE_URL` environment variable is set. One way to do so is by creating a `.env` file. Note that the file must be in the same directory as your schema.prisma file to automatically be picked up by the Prisma CLI.",
      "params": [
        {
          "label": "environmentVariable",
          "documentation": "The environment variable in which the database connection URL is stored."
        }
      ]
    }
  ],
  "generatorPreviewFeatures": [
    {
      "label": "connectOrCreate",
      "documentation": "While Prisma Client already provides an `upsert` query, which is available on the top-level of the Prisma Client API, we now also support `upsert`s in a *nested* manner. When writing data with Prisma Client, both in `update` and `create`, you can now provide an `upsert` operation on a related row by using this feature flag.\n\nPlease [share](https://github.com/prisma/prisma/issues/3103) your feedback on how this feature works for you. We are interested in both positive and negative feedback to help us gauge when this feature is ready for production! (If encounter any problems, please open a new issue here)."
    },
    {
      "label": "transactionApi",
      "documentation": "While Prisma already ships transactions within [nested writes](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/relation-queries#nested-writes), there are many use cases, where you might want to perform multiple *unrelated* write operations in a transaction and rollback, if one of them fails.\nBy wrapping your write operations in the new `transaction()` function, you can achieve exactly this!\n\n(Note, that these transactions are not long-running and are executed directly after each other. This is an explicit design decision of Prisma. In case this does not cover your use case yet, please chime in on [GitHub](https://github.com/prisma/prisma-client-js/issues/742)).\nAlternatively, you can store the unresolved promises in variables and pass these to the new transaction function.\n\n\n\nPlease [share your feedback](https://github.com/prisma/prisma/issues/3104) on how this feature works for you. We are interested in both positive and negative feedback to help us gauge when this feature is ready for production! (If encounter any problems, please open a new issue [here](https://github.com/prisma/prisma/issues/new/choose))."
    },
    {
      "label": "insensitiveFilters",
      "documentation": "Case insensitive scalar filters for supported DBs. Only postgres has any implementation at the moment, as SQLite doesn't reliably support insensitive filtering and MySQL is insensitive by default."
    },
    {
      "label": "nativeTypes",
      "documentation": "Allows to define custom types that should be used for a given field."
    }
  ],
  "generatorProviders": [
    {
      "label": "prisma-client-js",
      "documentation": "Built-in generator."
    }
  ],
  "generatorProviderArguments": [
    {
      "label": "\"\"",
      "documentation": "Specifies a single provider."
    }
  ],
  "datasourceProviders": [
    {
      "label": "mysql",
      "documentation": "Specifies a MySQL data source. Learn more about the MySQL data source connector [here](https://www.prisma.io/docs/reference/database-connectors/mysql)."
    },
    {
      "label": "postgresql",
      "documentation": "Specifies a PostGreSQL data source. Learn more about the PostgreSQL data source connector [here](https://www.prisma.io/docs/reference/database-connectors/postgresql)."
    },
    {
      "label": "sqlite",
      "documentation": "Specifies a SQLite data source. Learn more about the SQLite data source connector [here](https://www.prisma.io/docs/reference/database-connectors/sqlite)."
    }
  ],
  "datasourceProviderArguments": [
    {
      "label": "[]",
      "documentation": "Specifies multiple providers."
    },
    {
      "label": "\"\"",
      "documentation": "Specifies a single provider."
    }
  ],
  "generatorPreviewFeaturesArguments": [
    {
      "label": "[]",
      "documentation": "Enables preview feature flags."
    },
    {
      "label": "\"\"",
      "documentation": "Enables a preview feature flag."
    }
  ],
  "nativeTypes": {
    "mysql": {
      "Int": [
        {
          "label": "Int",
          "documentation": "Exact numeric data type. MySQL treats *Int* as a synonym for *Integer*."
        },
        {
          "label": "SmallInt",
          "documentation": "Exact numeric data type."
        },
        {
          "label": "TinyInt",
          "documentation": "Exact numeric data type."
        },
        {
          "label": "MediumInt",
          "documentation": "Exact numeric data type."
        },
        {
          "label": "BigInt",
          "documentation": "Exact numeric data type."
        }
      ],
      "Decimal": [
        {
          "label": "Decimal()",
          "fullSignature": "Decimal(m: u8, d: u8)",
          "documentation": "Exact numeric data type. Used when it is important to preserve exact precision, for example with monetary data.",
          "params": [
            {
              "label": "m",
              "documentation": "*m* is the maximum number of digits (the precision). It has a range of 1 to 65."
            },
            {
              "label": "d",
              "documentation": "*d* is the number of digits to the right of the decimal point (the scale). It has a range of 0 to 30 and must be no larger than *m*."
            }
          ]
        },
        {
          "label": "Numeric()",
          "fullSignature": "Numeric(m: u8, d: u8)",
          "documentation": "Exact numeric data type. Used when it is important to preserve exact precision, for example with monetary data. In MYSQL, *Numeric* is implemented as *Decimal*.",
          "params": [
            {
              "label": "m",
              "documentation": "*m* is the maximum number of digits (the precision). It has a range of 1 to 65."
            },
            {
              "label": "d",
              "documentation": "*d* is the number of digits to the right of the decimal point (the scale). It has a range of 0 to 30 and must be no larger than *m*."
            }
          ]
        },
        {
          "label": "Year",
          "documentation": "1-byte type used to represent year values with an implicit display width of 4 characters."
        }
      ],
      "Float": [
        {
          "label": "Float",
          "documentation": "Approximate numeric data type."
        },
        {
          "label": "Double",
          "documentation": "Approximate numeric data type. MySQL treats *Double* as a synonym for *DoublePre"
        }
      ],
      "String": [
        {
          "label": "Char()",
          "fullSignature": "Char(n: u32)",
          "documentation": "",
          "params": [
            {
              "label": "n",
              "documentation": "Indicates the maximum number of characters you want to store."
            }
          ]
        },
        {
          "label": "VarChar()",
          "fullSignature": "VarChar(n: u32)",
          "documentation": "",
          "params": [
            {
              "label": "n",
              "documentation": "Indicates the maximum number of characters you want to store."
            }
          ]

        },
        {
          "label": "TinyText"
        },
        {
          "label": "MediumText"
        },
        {
          "label": "LongText"
        }
      ],
      "Bytes": [
        {
          "label": "Bit()",
          "fullSignature": "Bit(m: u32)",
          "documentation": "",
          "params": [
            {
              "label": "m",
              "documentation": "A type of Bit(*m*) enables storage of *m*-bit values. *m* can range from 1 to 64."
            }
          ]
        },
        {
          "label": "Binary()",
          "fullSignature": "Binary(m: u32)",
          "documentation": "",
          "params": [
            {
              "label": "m",
              "documentation": "Indicates the maximum number of bytes you want to store."
            }
          ]
        },
        {
          "label": "VarBinary()",
          "fullSignature": "VarBinary(m: u32)",
          "documentation": "",
          "params": [
            {
              "label": "m: u32",
              "documentation": "Indicates the maximum number of bytes you want to store."
            }
          ]
        },
        {
          "label": "TinyBlob"
        },
        {
          "label": "MediumBlob"
        },
        {
          "label": "LongBlob"
        }
      ],
      "DateTime": [
        {
          "label": "Date"
        },
        {
          "label": "Time()",
          "fullSignature": "Time(m: Optional<u32>)",
          "params": [
            {
              "label": "m",
              "documentation": ""
            }
          ]
        },
        {
          "label": "Datetime"
        },
        {
          "label": "Timestamp"
        }
      ],
      "Json": [
        {
          "label": "Json"
        }
      ]
    },
    "postgresql": {
      "Int": [
        {
          "label": "SmallInt"
        },
        {
          "label": "Integer"
        },
        {
          "label": "BigInt"
        },
        {
          "label": "SmallSerial"
        },
        {
          "label": "BigSerial"
        }
      ],
      "Decimal": [
        {
          "label": "Decimal"
        },
        {
          "label": "Numeric"
        }
      ],
      "Float": [
        {
          "label": "Real"
        },
        {
          "label": "DoublePrecision"
        }
      ],
      "String": [
        {
          "label": "VarChar"
        },
        {
          "label": "Char"
        },
        {
          "label": "Text"
        },
        {
          "label": "Bit"
        },
        {
          "label": "VarBit"
        },
        {
          "label": "UUID"
        }
      ],
      "Bytes": [
        {
          "label": "ByteA"
        }
      ],
      "DateTime": [
        {
          "label": "Timestamp"
        },
        {
          "label": "TimestampWithTimezone"
        },
        {
          "label": "Date"
        },
        {
          "label": "Time"
        },
        {
          "label": "TimeWithTimezone"
        }
      ],
      "Interval": [
        {
          "label": "Interval"
        }
      ],
      "XML": [
        {
          "label": "XML"
        }
      ],
      "Json": [
        {
          "label": "Json"
        },
        {
          "label": "JsonB"
        }
      ]
    }
  }
}